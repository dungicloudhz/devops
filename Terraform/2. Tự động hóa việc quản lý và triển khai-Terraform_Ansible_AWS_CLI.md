# 1. Tìm hiểu về Terraform fmt, validate, plan và apply

**Terrafrom init (initialize)** - là sự bắt đầu của tất cả các privider và các nhà dịch vụ và các plugin, các module terraform code của chúng ta để tạo ra các tài nguyên cloud (hệ thống đám mây) 
1. Khởi tạo thư mục làm việc. `Tải xuống và bao gồm tất cả các module và Provider (ngoại trừ bên thứ ba) trong Terraform file`.
2. Cần được chạy trước khi triển khai cơ sở hạ tầng. `Vì các giai đoạn khác của việc triển khai Terraform yêu cầu provider, plugins và modules, lệnh này cần phải được chạy đầu tiên`.
3. Đồng bộ hóa cấu hình, an toàn để chạy. `Lệnh **terraform init** sẽ thiết lập cấu hình backend để lưu trữ trạng thái của cơ sở hạ tầng. Nó sẽ không làm thay đổi hoặc xóa bất cứ cài đặt cấu hình hoặc trạng thái hiện tại nào, mà chỉ đồng bộ hóa cấu hình để chuẩn bị cho việc triển khai.`

**Terraform fmt (format)** - lệnh format để làm đẹp code
1. Định dạng các template. `Làm các Terraform templates trông dễ nhìn và dễ đọc`.
2. Giúp duy trì cide một cách nhất quán. `Duy trì nhất quán định dạng code, đặc biệt là nếu các nhóm phát triển đang cùng làm việc và theo dõi Terraform code thông qua việc kiểm soát phiên bản`.
3. An toàn để chạy tại mọi thời điểm. `Không thay đổi hoặc thêm bất kỳ code mới nào vào file Terraform hiện tại. Thay vào đó, nó chỉ đơn giản làm cho code hiện tại trông đẹp hơn, dễ học hơn và tuân thủ theo một định dạng chuẩn.`

**Terraform validate**
1. Kiểm tra các file cấu hình (config files). `Kiểm tra lỗi cú pháp và tính nhất quán bên trong (ví dụ: Lỗi chính tả và lỗi cấu hình tài nguyên sai)`.
2. Cần phải chạy terraform init trước. `Yêu cầu một thư mục làm việc được khởi tạo, do đó lệnh init cần được chạy trước khi validate có thể chạy`.
3. An toàn để chạy bất cứ lúc nào. `Trường hợp sử dụng là chạy lệnh này để kiểm tra vấn đề trong TF code trước khi commit vào version control`.

**Terraform plan**
1. Tạo ra kế hoạch thực thi. `Terraform tính toán sự khác biệt giữa trạng thái yêu cầu và trạng thái hiện tại để tạo ra một kế hoạch thực thi`.
2. An toàn trước khi triển khai thật.  `Đây là một bước kiểm tra để xem liệu kế hoạch thực thi phù hợp với kế hoạch mà chúng ta muốn, trước khi tạo ra hoặc sửa đổi cơ sở hạ tầng`.
3. Kế hoạch thư thi có thể được lưu lại bằng cách sử dụng tham số `-out`. `Tuy nhiên, cần phải nhận thức các cấu hình nhạy cảm cũng sẽ được lưu lại trong một file dưới dạng văn bản`.

**Terraform apply (Deploy)** - Lệnh quan trọng nhất
1. Triển khai kế hoạch thực thi! `Áp dụng các thay đổi cần thiết để đạt được trạng thái mong muốn của Terraform code`.
2. Mặc định sẽ hiển thị thông báo trước khi triển khai. `Theo mặc định, người dùng cần phải gõ "yes" một cách rõ ràng trước khi một cơ sở hạ tầng được triển khai`.
3. Sẽ hiển thị kế hoạch thự thi một lần nữa
`Terraform apply sẽ hiển thị kế hoạch (plan) thực thi một lần nữa trước khi yêu cầu triển khai thật các tài nguyên`.

# 2. Lưu trữ tạng thái (State) Terraform trong S3 backend

** **
1. Xác định cách lưu trữ trạng thái
2. Mặc định, Terraform state được lưu trữ trong Local disk
3. Các biến không thể được sử dụng trong cấu hình Backends

Ví dụ backend trong một Terraform block sử dụng S3
```terraform
terraform
{
    required_version = ">=0.12.0"
    backend "s3"
        {
            region = "us-east-1"
            profile = "default"
            key = "<arbitrary-state-file-name>"
            bucket = "<name-of-already-created-bucket>"
        }
}
```

```bash
# Tiếp tục câu lệnh nối tiếp từ bài trước
cd tf_ansible_deploy

aws s3api create-bucket --bucket <name_s3_bucket>
# {
#     "Location": "/<name_s3_bucket>"
# }

vim backend.tf # tạo file cấu hình
--- chỉnh sửa file backend.tf
terraform {
    required_version = ">=0.12.0"
    required_provider {
        aws = ">=3.0.0"
    }
}
backend "s3" {
    region = "us-east-1"
    profile = "default"
    key = "<arbitrary-state-file-name>"
    bucket = "<name-of-already-created-bucket>"
}
---

:wq # thực hiện thoát file

# Khởi tạo thư mục workspace
terraform init
# Định dạng lại các dòng code trong file backend
terraform fmt

cat backend.tf # Xem lại file Kiểm tra file xem đã dễ đọc hơn
```

# 3. Set up nhiều AWS Providers trong Terraform

Các providers thực hiện các tương tác với API của nahf cung cấp như AWS và Azure. Chúng cũng cung cấp logic để quản lý, cập nhật và tạo các tài nguyên trong Terraform.

**Khai báo nhiều nhà cung cấp AWS (AWS Providers)**
```yaml
Provider "aws"
{
    profile = var.profile
    region = var.region-master
    alias = "region-master"
}
Provider "aws"
{
    profile = var.profile
    region = var.region-worker
    alias = "region-worker"
}
```

```bash
pwd
# /root/tf_ansible_deploy

vim variable.tf
variable "profile" 
{
    type = string
    default = "default"
}
variable "region-master" 
{
    type = string
    default = "us-east-1"
}
variable "region-worker" 
{ 
    type = string
    default = "us-west-1"
}

vim provider.tf
profile "aws"
{
    profile = var.profile
    region = var.region-master
    alias = "region-master"
}
profile "aws"
{
    profile = var.profile
    region = var.region-worker
    alias = "region-worker"
}

# Chạy lệnh terraform init
terraform init
# Initializing the backend ...
ls -al # hiển thị toàn bộ thư mục (cả thư mục ẩn)

cd /.terraform
ls
# providers terraform.tfstate
cd /providers
ls
# registry.terraform.io
cd registry.terraform.io
ls
# hashicorp
cd hashicorp
...
ll
# terraform-provider-aws_v5.43.0_x5
```

# 4. Network Setup Phần 1 Triển khai VPCs, Internet GWs và Subnets
Mục đích bài học: Triển khai hệ thống mạng
Chú ý: Setup S3 Backend và nhiều AWS Providers `Đừng quên setup S3 backend và hai AWS Providers, như đã được học trong các videos của bài học trước.`

```bash
vim network.tf
# triển khai các tài nguyên network
# Create VPC in us-east-1
resource "aws_pvc" "vpc_master" {
    provider = aws.region-master # chỉ định đang sử dụng tài nguyên của AWS
    cidr_block = "10.0.0.0/16"
    enable_dns_support = true
    enable_dns_hostnames = true
    tags = {
        Name = "master-vpc-jenkins"
    }
}
# Create VPC in us-west-1
resource "aws_vpc" "vpc_master_cali" {
    provider = aws.region-worker
    cidr_block = "192.168.0.0/16"
    enable_dns_support = true
    enable_dns_hostnames = true
    tags = {
        Name = "worker-vpc-jenkins"
    } 
}
# Create IGW in us-east-1
resource "aws_internet_gateway" "igw" {
    provider = aws.region-master
    vpc_id = aws_vpc.vpc_master.id
}
# Create IGW in us-west-1
resource "aws_internet_gateway" "igw-cali" {
    provider = aws.region-worker
    vpc_id = aws_vpc.vpc_master_cali.id
}
# Get all available AZ's in VPC for master region
data "aws_availability_zones" "azs" {
    provider = aws.region-master
    state = "available"
}
# Create subnet # 1 in us-east-1
resource "aws_subnet" "subnet_1" {
    provider = aws.region-master
    availavility_zone = element(data.aws_availability_zones.azs.names, 0) # Lấy tên của AZ đầu tiên trong danh sách từ ...
    vpc_id = aws_vpc.vpc_master.id  
    cidr_block = "10.0.1.0/24"
}
# Create subnet #2 in us-east-1
resource "aws_subnet" "subnet_2" {
    provider = aws.region-master
    vpc_id = aws_vpc.vpc_master.id
    availability_zone = element(data.aws_availibility_zones.azs.names, 1)
    cidr_block = "10.0.2.0/24"
}
# Create subnet in us-west-1
resource "aws_subnet" "subnet_1_cali" {
    provider = aws.region-worker
    vpc_id = aws_vpc.vpc_master_cali.id
    cidr_block = "192.168.1.0/24"
}
# end file

terraform fmt
terraform init
terraform plan
terraform apply
```
